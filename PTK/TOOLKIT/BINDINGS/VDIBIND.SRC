/* LIBMAN: ALL: NAME: VDIBIND.C */
/******************************************************************************
 *
 *    Modulname   :  VDIBIND.C
 *
 *    Author      :  John Grant
 *    Version     :  1.0
 *    Created     :  18 July, 1984 - April 19, 1985
 *
 *    Author      :  unknown
 *    Version     :  1.1
 *    Modified    :  unknown
 *       Modified for use with LARGE Model
 *
 *    Author      :  Robert Schneider, DR GmbH
 *    Version     :  1.4
 *    Modified    :  April 12, 1989 - April 17, 1989
 *       Cleaned up the whole source for use with new C-Compilers
 *       (Turbo-C 2.0, MS-C 5.1) that do ANSI-C-Prototyping.
 *       Also inserted LIBMAN-Comments to allow users to install
 *       the bindings either as one big source, or splitted in
 *       the Managers-Libraries (appl, evnt, ...), or splitted each
 *       function into a separate source to achieve smallest possible
 *       executable-size.
 *
 *****************************************************************************
 *
 *	-------------------------------------------------------------
 *	GEM Desktop					  Version 3.1
 *	Serial No.  XXXX-0000-654321		  All Rights Reserved
 *	Copyright (C) 1985 - 1989		Digital Research Inc.
 *	-------------------------------------------------------------
 *
 *****************************************************************************/

#include "portab.h"
#include "vdi.h"

EXTERN WORD contrl[], intin[], ptsin[], intout[], ptsout[];

typedef struct gsx_parameters {

    WORD FAR *contrl;
    WORD FAR *intin;
    WORD FAR *ptsin;
    WORD FAR *intout;
    WORD FAR *ptsout;

}GSXBLK;

GSXBLK pblock = {

   (WORD FAR *)contrl,
   (WORD FAR *)intin,
   (WORD FAR *)ptsin,
   (WORD FAR *)intout,
   (WORD FAR *)ptsout

};

GSXBLK FAR *gsx_p = &pblock;

#if HIGH_C

#include <msdos.cf>

VOID vdi()
{
   Registers.CX.R = 0x473;
   Registers.DX.R = FPOFF(&pblock);
   Registers.DS.R = FPSEG(&pblock);

   callint(0xef);
}

#else /* if HIGH_C */

#include <dos.h>

MLOCAL union REGS regs;
MLOCAL struct SREGS segregs;

VOID vdi()
{
   regs.x.cx  = 0x473;
   regs.x.dx  = FPOFF(gsx_p);
   segregs.ds = FPSEG(gsx_p);
   int86x(0xef,&regs,&regs,&segregs);
}

#endif

WORD gemcheck()
{
   BYTE FAR *bp;

   bp = *(BYTE FAR * FAR *)MKFP(0,0x3bc);

   if (bp[2] != 'G' || bp[3] != 'E' || bp[4] != 'M')
        return(FALSE);

   return(TRUE);
}

/* LIBMAN: LIB: HDR: NAME: CONTROL.C */

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_GETDRV.C */
/*
 * info_select = 
 *                1  :  get full driver filename
 *                2  :  get short device name
 *                3  :  get long device name
 *                4  :  get font path string
 *                5  :  get driver patch byte(s)
 */

VOID v_get_driver_info(device_id, info_select, info_string)
WORD device_id;
WORD info_select;
UBYTE FAR *info_string;
{
   WORD ii;
   BYTE *bptr;
    
   contrl[ 0 ] = -1 ;
   contrl[ 1 ] = 0 ;
   contrl[ 3 ] = 2 ;
   contrl[ 5 ] = 4 ;
   contrl[ 6 ] = 0 ;
   intin[ 0 ] = device_id ;
   intin[ 1 ] = info_select ;
   vdi() ;
   if ( info_select != 5 )
   {
      bptr = (BYTE *) intout ;
      for ( ii = 0; ii < contrl[ 4 ]; ii ++ )
         *info_string++ = *bptr++ ;
      *info_string = 0 ;
   }
   else
      *(WORD FAR *)info_string = intout[ 0 ] ;
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_OPNWK.C */

VOID v_opnwk( work_in, handle, work_out )
WORD FAR *work_in;
WORD FAR *handle;
WORD FAR *work_out;
{
   pblock.intin  = work_in;
   pblock.intout = work_out;
   pblock.ptsout = &work_out[45];

   contrl[0] = 1;
   contrl[1] = 0;
   contrl[3] = 103 ;

   vdi();

   *handle = contrl[6];    

   pblock.intin = intin;
   pblock.intout = intout;
   pblock.ptsout = ptsout;
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_CLSWK.C */

VOID v_clswk( handle )
WORD handle;
{
    contrl[0] = 2;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_CLRWK.C */

VOID v_clrwk( handle )
WORD handle;
{
    contrl[0] = 3;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_UPDWK.C */

VOID v_updwk( handle )
WORD handle;
{
    contrl[0] = 4;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_OPNVWK.C */

VOID v_opnvwk( work_in, handle, work_out )
WORD FAR *work_in;
WORD FAR *handle;
WORD FAR *work_out;
{
   pblock.intin  = work_in;
   pblock.intout = work_out;
   pblock.ptsout = &work_out[45];

   contrl[0] = 100;
   contrl[1] = 0;
   contrl[3] = 11;
   contrl[6] = *handle;

   vdi();

   *handle = contrl[6];    

   pblock.intin = intin;
   pblock.intout = intout;
   pblock.ptsout = ptsout;
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_CLSVWK.C */

VOID v_clsvwk( handle )
WORD handle;
{
    contrl[0] = 101;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\VST_LOAD.C */

WORD vst_load_fonts( handle, select )
WORD handle, select;
{
    contrl[0] = 119;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\VST_UNLO.C */

VOID vst_unload_fonts( handle, select )
WORD handle, select;
{
    contrl[0] = 120;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\VST_EX_L.C */

WORD vst_ex_load_fonts( handle, select, font_max, font_free )
WORD handle, select, font_max, font_free;
{
    contrl[0] = 119;
    contrl[1] = 0;
    contrl[3] = 3;
    contrl[6] = handle;

    intin[0] = select;
    intin[1] = font_max;
    intin[2] = font_free;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\VS_CLIP.C */

VOID vs_clip( handle, clip_flag, xy )
WORD handle, clip_flag;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    intin[0] = clip_flag;

    contrl[0] = 129;
    contrl[1] = 2;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_SETAPP.C */

VOID v_set_app_buff(address, nparagraphs)
VOID FAR *address;
WORD nparagraphs;
{
   contrl[0] = -1;
   contrl[1] = 0;
   contrl[3] = 3;

   intin[0] = FPOFF(address);
   intin[1] = FPSEG(address);
   intin[2] = nparagraphs;

   vdi();
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_BEZ_ON.C */

WORD v_bez_on(handle)
WORD handle;
{
   contrl[0] = 11;
   contrl[1] = 1;
   contrl[3] = 0;
   contrl[5] = 13;
   contrl[6] = handle;

   vdi();

   return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_BEZ_OF.C */

WORD v_bez_off(handle)
WORD handle;
{
   contrl[0] = 11;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 13;
   contrl[6] = handle;

   vdi();

   return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_BEZQUA.C */

WORD v_bez_qual(handle, prcnt)
WORD handle, prcnt;
{
   contrl[0] = 5;
   contrl[1] = 0;
   contrl[3] = 3;
   contrl[5] = 99;
   contrl[6] = handle;

   intin[0] = 32;
   intin[1] = 1;
   intin[2] = prcnt;

   vdi();

   return (intout[0]);
}

/* LIBMAN: SRC: HDR: NAME: CONTROL\V_P_ROT.C */

VOID v_pat_rotate(handle, angle)
WORD handle, angle;
{
   contrl[0] = 134;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[6] = handle;

   intin[0] = angle;

   vdi();
}

/* LIBMAN: LIB: HDR: NAME: OUTPUT.C */

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_PLINE.C */

VOID v_pline( handle, count, xy )
WORD handle, count;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    contrl[0] = 6;
    contrl[1] = count;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_PMARK.C */

VOID v_pmarker( handle, count, xy )
WORD handle, count;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    contrl[0] = 7;
    contrl[1] = count;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_GTEXT.C */

VOID v_gtext( handle, x, y, string)
WORD handle, x, y;
BYTE FAR *string;
{
    WORD i;

    ptsin[0] = x;
    ptsin[1] = y;
    i = 0;
    while ((intin[i++] = (WORD)(UBYTE)*string++) != 0)
        ;

    contrl[0] = 8;
    contrl[1] = 1;
    contrl[3] = --i;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_ETEXT.C */

VOID v_etext( handle, x, y, string, offsets)
WORD handle, x, y;
WORD FAR *offsets;
UBYTE FAR *string;
{
    WORD FAR *intptr;
    WORD FAR *ptsptr;
    
    intptr = intin;
    ptsptr = ptsin;
    *ptsptr++ = x;
    *ptsptr++ = y;
    while ((*intptr++ = *string++) != 0)
    {
        *ptsptr++ = *offsets++;
        *ptsptr++ = *offsets++;
    }

    contrl[0] = 11;
    contrl[1] = (LONG)intptr - (LONG)intin;
    contrl[3] = (LONG)intptr - (LONG)intin - 1;
    contrl[5] = 11;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_FILLA.C */

VOID v_fillarea( handle, count, xy)
WORD handle, count;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    contrl[0] = 9;
    contrl[1] = count;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_CELLAR.C */

VOID v_cellarray( handle, xy, row_length, el_per_row, num_rows, wr_mode,
								        colors )
WORD handle;
WORD FAR *xy;
WORD row_length, el_per_row, num_rows, wr_mode;
WORD FAR *colors;
{
    pblock.intin = colors;
    pblock.ptsin = xy;

    contrl[0] = 10;
    contrl[1] = 2;
    contrl[3] = row_length * num_rows;
    contrl[6] = handle;
    contrl[7] = row_length;
    contrl[8] = el_per_row;
    contrl[9] = num_rows;
    contrl[10] = wr_mode;

    vdi();

    pblock.intin = intin;
    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_BAR.C */

VOID v_bar( handle, xy )
WORD handle;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    contrl[0] = 11;
    contrl[1] = 2;
    contrl[3] = 0;
    contrl[5] = 1;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_ARC.C */

VOID v_arc( handle, xc, yc, rad, sang, eang )
WORD handle, xc, yc, rad, sang, eang;
{
    ptsin[0] = xc;
    ptsin[1] = yc;
    ptsin[2] = ptsin[3] = ptsin[4] = ptsin[5] = ptsin[7] = 0;
    ptsin[6] = rad;

    intin[0] = sang;
    intin[1] = eang;

    contrl[0] = 11;
    contrl[1] = 4;
    contrl[3] = 2;
    contrl[5] = 2;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_PIESL.C */

VOID v_pieslice( handle, xc, yc, rad, sang, eang )
WORD handle, xc, yc, rad, sang, eang;
{
    ptsin[0] = xc;
    ptsin[1] = yc;
    ptsin[2] = ptsin[3] = ptsin[4] = ptsin[5] = ptsin[7] = 0;
    ptsin[6] = rad;

    intin[0] = sang;
    intin[1] = eang;

    contrl[0] = 11;
    contrl[1] = 4;
    contrl[3] = 2;
    contrl[5] = 3;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_CIRCLE.C */

VOID v_circle( handle, xc, yc, rad )
WORD handle, xc, yc, rad;
{
    ptsin[0] = xc;
    ptsin[1] = yc;
    ptsin[2] = ptsin[3] = ptsin[5] = 0;
    ptsin[4] = rad;

    contrl[0] = 11;
    contrl[1] = 3;
    contrl[3] = 0;
    contrl[5] = 4;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_ELLIPS.C */

VOID v_ellipse( handle, xc, yc, xrad, yrad )
WORD handle, xc, yc, xrad, yrad;
{
    ptsin[0] = xc;
    ptsin[1] = yc;
    ptsin[2] = xrad;
    ptsin[3] = yrad;

    contrl[0] = 11;
    contrl[1] = 2;
    contrl[3] = 0;
    contrl[5] = 5;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_ELLARC.C */

VOID v_ellarc( handle, xc, yc, xrad, yrad, sang, eang )
WORD handle, xc, yc, xrad, yrad, sang, eang;
{
    ptsin[0] = xc;
    ptsin[1] = yc;
    ptsin[2] = xrad;
    ptsin[3] = yrad;

    intin[0] = sang;
    intin[1] = eang;

    contrl[0] = 11;
    contrl[1] = 2;
    contrl[3] = 2;
    contrl[5] = 6;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_ELLPIE.C */

VOID v_ellpie( handle, xc, yc, xrad, yrad, sang, eang)
WORD handle, xc, yc, xrad, yrad, sang, eang;
{
    ptsin[0] = xc;
    ptsin[1] = yc;
    ptsin[2] = xrad;
    ptsin[3] = yrad;

    intin[0] = sang;
    intin[1] = eang;

    contrl[0] = 11;
    contrl[1] = 2;
    contrl[3] = 2;
    contrl[5] = 7;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_RBOX.C */

VOID v_rbox( handle, xy )
WORD handle;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    contrl[0] = 11;
    contrl[1] = 2;
    contrl[3] = 0;
    contrl[5] = 8;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_RFBOX.C */

VOID v_rfbox( handle, xy )
WORD handle;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    contrl[0] = 11;
    contrl[1] = 2;
    contrl[3] = 0;
    contrl[5] = 9;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_JUSTI.C */

VOID v_justified( handle, x, y, string, length, word_space, char_space)
WORD handle, x, y, length, word_space, char_space;
BYTE FAR *string;
{
    WORD *intstr;

    ptsin[0] = x;
    ptsin[1] = y;
    ptsin[2] = length;
    ptsin[3] = 0;

    intin[0] = word_space;
    intin[1] = char_space;

    intstr = &intin[2];
    while ((*intstr++ = (WORD)(UBYTE)*string++) != 0)
        ;

    contrl[0] = 11;
    contrl[1] = 2;
    contrl[3] = intstr - intin - 1;
    contrl[5] = 10;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_CONFIL.C */

VOID v_contourfill( handle, x, y, index )
WORD handle, x, y, index;
{
    intin[0] = index;
    ptsin[0] = x;
    ptsin[1] = y;

    contrl[0] = 103;
    contrl[1] = contrl[3] = 1;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\VR_RECFL.C */

VOID vr_recfl( handle, xy )
WORD handle;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    contrl[0] = 114;
    contrl[1] = 2;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: OUTPUT\V_BEZIER.C */

MLOCAL VOID v_bezier_all(opcode, handle, count, xyarr, bezarr, minmax, npts,
									  nmove)
WORD opcode;
WORD handle, count;
WORD FAR *xyarr;
UBYTE FAR *bezarr;
WORD FAR *minmax;
WORD FAR *npts;
WORD FAR *nmove;
{
   contrl[0] = opcode;
   contrl[1] = count;
   contrl[3] = (count + 1) / 2;
   contrl[5] = 13;
   contrl[6] = handle;

   pblock.intin = (WORD FAR *)bezarr;
   pblock.ptsin = xyarr;

   vdi();

   pblock.intin = intin;
   pblock.ptsin = ptsin;

   *npts = intout[0];
   *nmove = intout[1];
   minmax[0] = ptsout[0];
   minmax[1] = ptsout[1];
   minmax[2] = ptsout[2];
   minmax[3] = ptsout[3];   
}

VOID v_bez(handle, count, xyarr, bezarr, minmax, npts, nmove)
WORD handle, count;
WORD FAR *xyarr;
UBYTE FAR *bezarr;
WORD FAR *minmax;
WORD FAR *npts;
WORD FAR *nmove;
{
   v_bezier_all(6, handle, count, xyarr, bezarr, minmax, npts, nmove);
}

VOID v_bezfill(handle, count, xyarr, bezarr, minmax, npts, nmove)
WORD handle, count;
WORD FAR *xyarr;
UBYTE FAR *bezarr;
WORD FAR *minmax;
WORD FAR *npts;
WORD FAR *nmove;
{
   v_bezier_all(9, handle, count, xyarr, bezarr, minmax, npts, nmove);
}

/* LIBMAN: LIB: HDR: NAME: ATTRIB.C */

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSWR_MOD.C */

WORD vswr_mode( handle, mode )
WORD handle, mode;
{
    intin[0] = mode;

    contrl[0] = 32;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VS_COLOR.C */

VOID vs_color( handle, index, rgb )
WORD handle, index;
WORD FAR *rgb;
{
    WORD i;

    intin[0] = index;
    for ( i = 1; i < 4; i++ )
        intin[i] = *rgb++;

    contrl[0] = 14;
    contrl[1] = 0;
    contrl[3] = 4;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSL_TYPE.C */

WORD vsl_type( handle, style )
WORD handle, style;
{
    intin[0] = style;

    contrl[0] = 15;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSL_UDST.C */

VOID vsl_udsty( handle, pattern )
WORD handle, pattern;
{
    intin[0] = pattern;

    contrl[0] = 113;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSL_WIDT.C */

WORD vsl_width( handle, width )
WORD handle, width;
{
    ptsin[0] = width;
    ptsin[1] = 0;

    contrl[0] = 16;
    contrl[1] = 1;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    return( ptsout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSL_COL.C */

WORD vsl_color( handle, index )
WORD handle, index;
{
    intin[0] = index;

    contrl[0] = 17;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSL_ENDS.C */

VOID vsl_ends( handle, beg_style, end_style)
WORD handle, beg_style, end_style;
{
    intin[0] = beg_style;
    intin[1] = end_style;

    contrl[0] = 108;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSM_TYPE.C */

WORD vsm_type( handle, symbol )
WORD handle, symbol;
{
    intin[0] = symbol;

    contrl[0] = 18;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSM_HEIG.C */

WORD vsm_height( handle, height )
WORD handle, height;
{
    ptsin[0] = 0;
    ptsin[1] = height;

    contrl[0] = 19;
    contrl[1] = 1;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    return( ptsout[1] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSM_COL.C */

WORD vsm_color( handle, index )
WORD handle, index;
{
    intin[0] = index;

    contrl[0] = 20;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VST_HEIG.C */

VOID vst_height( handle, height, char_width, char_height, cell_width,
								   cell_height )
WORD handle, height;
WORD FAR *char_width;
WORD FAR *char_height;
WORD FAR *cell_width;
WORD FAR *cell_height;
{
    ptsin[0] = 0;
    ptsin[1] = height;

    contrl[0] = 12;
    contrl[1] = 1;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    *char_width = ptsout[0];
    *char_height = ptsout[1];
    *cell_width = ptsout[2];
    *cell_height = ptsout[3];
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VST_POIN.C */

WORD vst_point( handle, point, char_width, char_height, cell_width,
								   cell_height )
WORD handle, point;
WORD FAR *char_width;
WORD FAR *char_height;
WORD FAR *cell_width;
WORD FAR *cell_height;
{
    intin[0] = point;

    contrl[0] = 107;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    *char_width = ptsout[0];
    *char_height = ptsout[1];
    *cell_width = ptsout[2];
    *cell_height = ptsout[3];

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VST_ROT.C */

WORD vst_rotation( handle, angle )
WORD handle, angle;
{
    intin[0] = angle;

    contrl[0] = 13;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VST_FONT.C */

WORD vst_font( handle, font )
WORD handle, font;
{
    intin[0] = font;

    contrl[0] = 21;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VST_COL.C */

WORD vst_color( handle, index )
WORD handle, index;
{
    intin[0] = index;

    contrl[0] = 22;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VST_EFF.C */
    
WORD vst_effects( handle, effect )
WORD handle, effect;
{
    intin[0] = effect;

    contrl[0] = 106;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VST_ALIG.C */

VOID vst_alignment( handle, hor_in, vert_in, hor_out, vert_out )
WORD handle, hor_in, vert_in;
WORD FAR *hor_out;
WORD FAR *vert_out;
{
    intin[0] = hor_in;
    intin[1] = vert_in;

    contrl[0] = 39;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[6] = handle;

    vdi();

    *hor_out = intout[0];
    *vert_out = intout[1];
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSF_INT.C */

WORD vsf_interior( handle, style )
WORD handle, style;
{
    intin[0] = style;

    contrl[0] = 23;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSF_STYL.C */

WORD vsf_style( handle, index )
WORD handle, index;
{
    intin[0] = index;

    contrl[0] = 24;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSF_COL.C */

WORD vsf_color( handle, index )
WORD handle, index;
{
    intin[0] = index;

    contrl[0] = 25;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSF_PERI.C */

WORD vsf_perimeter( handle, per_vis )
WORD handle, per_vis;
{
    intin[0] = per_vis;

    contrl[0] = 104;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSF_XPER.C */

WORD vsf_xperimeter( handle, per_vis , per_style)
WORD handle, per_vis, per_style;
{
    intin[0] = per_vis;
    intin[1] = per_style;

    contrl[0] = 104;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VSF_UDPA.C */

VOID vsf_udpat( handle, fill_pat, planes )
WORD handle;
WORD FAR *fill_pat;
WORD planes;
{
    pblock.intin = fill_pat;

    contrl[0] = 112;
    contrl[1] = 0;
    contrl[3] = 16 * planes;
    contrl[6] = handle;

    vdi();

    pblock.intin = intin;   
}

/* LIBMAN: SRC: HDR: NAME: ATTRIB\VS_GRAYO.C */

VOID vs_grayoverride(handle, grayval)
WORD handle, grayval;
{
   contrl[0] = 133;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[6] = handle;

   intin[0] = grayval;

   vdi();
}

/* LIBMAN: LIB: HDR: NAME: RASTER.C */

/* LIBMAN: SRC: HDR: NAME: RASTER\V_GET_PI.C */

VOID v_get_pixel( handle, x, y, pel, index )
WORD handle, x, y;
WORD FAR *pel;
WORD FAR *index;
{
    ptsin[0] = x;
    ptsin[1] = y;

    contrl[0] = 105;
    contrl[1] = 1;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    *pel = intout[0];
    *index = intout[1];
}

/* LIBMAN: SRC: HDR: NAME: RASTER\VRO_CPY.C */

VOID vro_cpyfm( handle, wr_mode, xy, srcMFDB, desMFDB )
WORD handle, wr_mode;
WORD FAR *xy;
MFDB FAR *srcMFDB;
MFDB FAR *desMFDB;
{
    intin[0] = wr_mode;
    *(MFDB FAR* FAR*)&contrl[7] = srcMFDB;
    *(MFDB FAR* FAR*)&contrl[9] = desMFDB;
    pblock.ptsin = xy;

    contrl[0] = 109;
    contrl[1] = 4;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: RASTER\VR_TRNFM.C */

VOID vr_trnfm( handle, srcMFDB, desMFDB )
WORD handle;
MFDB FAR *srcMFDB;
MFDB FAR *desMFDB;
{
    *(MFDB FAR* FAR*)&contrl[7] = srcMFDB;
    *(MFDB FAR* FAR*)&contrl[9] = desMFDB;

    contrl[0] = 110;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: RASTER\VRT_CPY.C */

VOID vrt_cpyfm( handle, wr_mode, xy, srcMFDB, desMFDB, index )
WORD handle, wr_mode;
MFDB FAR *srcMFDB;
MFDB FAR *desMFDB;
WORD FAR *xy;
WORD FAR *index;
{
    intin[0] = wr_mode;
    intin[1] = *index++;
    intin[2] = *index;          

    *(MFDB FAR* FAR*)&contrl[7] = srcMFDB;
    *(MFDB FAR* FAR*)&contrl[9] = desMFDB;

    pblock.ptsin = xy;

    contrl[0] = 121;
    contrl[1] = 4;
    contrl[3] = 3;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: LIB: HDR: NAME: INPUT.C */

/* LIBMAN: SRC: HDR: NAME: INPUT\VSIN_MOD.C */

VOID vsin_mode( handle, dev_type, mode )
WORD handle, dev_type, mode;
{
    intin[0] = dev_type;
    intin[1] = mode;

    contrl[0] = 33;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VRQ_LOC.C */

VOID vrq_locator( handle, initx, inity, xout, yout, term )
WORD handle, initx, inity;
WORD FAR *xout;
WORD FAR *yout;
WORD FAR *term;
{
    ptsin[0] = initx;
    ptsin[1] = inity;

    contrl[0] = 28;
    contrl[1] = 1;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    *xout = ptsout[0];
    *yout = ptsout[1];
    *term = intout[0];
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VSM_LOC.C */

WORD vsm_locator( handle, initx, inity, xout, yout, term )
WORD handle, initx, inity;
WORD FAR *xout;
WORD FAR *yout;
WORD FAR *term;
{
    ptsin[0] = initx;
    ptsin[1] = inity;

    contrl[0] = 28;
    contrl[1] = 1;
    contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    *xout = ptsout[0];
    *yout = ptsout[1];
    *term = intout[0];

    return( (contrl[4] << 1) | contrl[2] );
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VRQ_VAL.C */

VOID vrq_valuator( handle, val_in, val_out, term )
WORD handle, val_in;
WORD FAR *val_out;
WORD FAR *term;
{
    intin[0] = val_in;

    contrl[0] = 29;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    *val_out = intout[0];
    *term = intout[1];
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VSM_VAL.C */

VOID vsm_valuator( handle, val_in, val_out, term, status )
WORD handle, val_in;
WORD FAR *val_out;
WORD FAR *term;
WORD FAR *status;
{
    intin[0] = val_in;

    contrl[0] = 29;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    *val_out = intout[0];
    *term = intout[1];
    *status = contrl[4];
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VRQ_CHO.C */

VOID vrq_choice( handle, in_choice, out_choice )
WORD handle, in_choice;
WORD FAR *out_choice;
{
    intin[0] = in_choice;

    contrl[0] = 30;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    *out_choice = intout[0];
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VSM_CHO.C */

WORD vsm_choice( handle, choice )
WORD handle;
WORD FAR *choice;
{
    contrl[0] = 30;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    *choice = intout[0];

    return( contrl[4] );
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VRQ_STR.C */

VOID vrq_string( handle, length, echo_mode, echo_xy, string)
WORD handle, length, echo_mode;
WORD FAR *echo_xy;
BYTE FAR *string;
{
    WORD    count;

    intin[0] = length;
    intin[1] = echo_mode;
    pblock.ptsin = echo_xy;

    contrl[0] = 31;
    contrl[1] = echo_mode;
    contrl[3] = 2;
    contrl[6] = handle;

    vdi();

    for (count = 0; count < contrl[4]; count++)
      *string++ = intout[count];
    *string = 0;  

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VSM_STR.C */

WORD vsm_string( handle, length, echo_mode, echo_xy, string )
WORD handle, length, echo_mode;
WORD FAR *echo_xy;
BYTE FAR *string;
{
    WORD    count;

    intin[0] = length;
    intin[1] = echo_mode;
    pblock.ptsin = echo_xy;

    contrl[0] = 31;
    contrl[1] = echo_mode;
    contrl[3] = 2;
    contrl[6] = handle;

    vdi();

    for (count = 0; count < contrl[4]; count++)
      *string++ = intout[count];
    *string = 0;  

    pblock.ptsin = ptsin;

    return( contrl[4] );
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VSC_FORM.C */

VOID vsc_form( handle, cur_form )
WORD handle;
WORD FAR *cur_form;
{
    pblock.intin = cur_form;

    contrl[0] = 111;
    contrl[1] = 0;
    contrl[3] = 37;
    contrl[6] = handle;

    vdi();

    pblock.intin = intin;
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VEX_TIMV.C */

VOID vex_timv( handle, tim_addr, old_addr, scale )
WORD handle;
WORD FAR *scale;
#if HIGH_C
FAR WORD (*tim_addr)();
FAR WORD (* FAR *old_addr)();
#else
WORD (FAR *tim_addr)();
WORD (FAR * FAR * old_addr)();
#endif
{

#if HIGH_C
    * (FAR WORD (* FAR *)()) &contrl[7] = tim_addr;
#else
    * (WORD (FAR * FAR *)()) &contrl[7] = tim_addr;
#endif
    contrl[0] = 118;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

#if HIGH_C
    *old_addr = *(FAR WORD (* FAR *)())&contrl[9];
#else
    *old_addr = *(WORD (FAR * FAR *)())&contrl[9];
#endif

    *scale = intout[0];
}

/* LIBMAN: SRC: HDR: NAME: INPUT\V_SHOW_C.C */

VOID v_show_c( handle, reset )
WORD handle, reset;
{
    intin[0] = reset;

    contrl[0] = 122;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: INPUT\V_HIDE_C.C */

VOID v_hide_c( handle )
WORD handle;
{
    contrl[0] = 123;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VQ_MOUSE.C */

VOID vq_mouse( handle, status, px, py )
WORD handle;
WORD FAR *status;
WORD FAR *px;
WORD FAR *py;
{
    contrl[0] = 124;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    *status = intout[0];
    *px = ptsout[0];
    *py = ptsout[1];
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VEX_BUTV.C */

VOID vex_butv( handle, usercode, savecode )
WORD handle;
#if HIGH_C
FAR WORD (* usercode)();
FAR WORD (* FAR * savecode)();
#else
WORD (FAR * usercode)();
WORD (FAR * FAR * savecode)();
#endif
{
#if HIGH_C
    *(FAR WORD (* FAR *)())&contrl[7] = usercode;
#else
    *(WORD (FAR * FAR *)())&contrl[7] = usercode;
#endif

    contrl[0] = 125;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

#if HIGH_C
    *savecode = *(FAR WORD (* FAR *)())&contrl[9];
#else
    *savecode = *(WORD (FAR * FAR *)())&contrl[9];
#endif
 }

/* LIBMAN: SRC: HDR: NAME: INPUT\VEX_MOTV.C */

VOID vex_motv( handle, usercode, savecode )
WORD handle;
#if HIGH_C
FAR WORD (* usercode)();
FAR WORD (* FAR * savecode)();
#else
WORD (FAR * usercode)();
WORD (FAR * FAR * savecode)();
#endif
{
#if HIGH_C
    *(FAR WORD (* FAR *)())&contrl[7] = usercode;
#else
    *(WORD (FAR * FAR *)())&contrl[7] = usercode;
#endif

    contrl[0] = 126;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

#if HIGH_C
    *savecode = *(FAR WORD (* FAR *)())&contrl[9];
#else
    *savecode = *(WORD (FAR * FAR *)())&contrl[9];
#endif
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VEX_CURV.C */

VOID vex_curv( handle, usercode, savecode )
WORD handle;
#if HIGH_C
FAR WORD (* usercode)();
FAR WORD (* FAR * savecode)();
#else
WORD (FAR * usercode)();
WORD (FAR * FAR * savecode)();
#endif
{
#if HIGH_C
    *(FAR WORD (* FAR *)())&contrl[7] = usercode;
#else
    *(WORD (FAR * FAR *)())&contrl[7] = usercode;
#endif

    contrl[0] = 127;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

#if HIGH_C
    *savecode = *(FAR WORD (* FAR *)())&contrl[9];
#else
    *savecode = *(WORD (FAR * FAR *)())&contrl[9];
#endif
}

/* LIBMAN: SRC: HDR: NAME: INPUT\VQ_KEY_S.C */

VOID vq_key_s( handle, status )
WORD handle;
WORD FAR *status;
{
    contrl[0] = 128;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    *status = intout[0];
}

/* LIBMAN: LIB: HDR: NAME: INQUIRE.C */

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQ_COLOR.C */

VOID vq_color( handle, index, set_flag, rgb )
WORD handle, index, set_flag;
WORD FAR *rgb;
{
    intin[0] = index;
    intin[1] = set_flag;

    contrl[0] = 26;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[6] = handle;

    vdi();

    rgb[0] = intout[1];
    rgb[1] = intout[2];
    rgb[2] = intout[3];
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQ_CELLA.C */

VOID vq_cellarray( handle, xy, row_len, num_rows, el_used, rows_used, stat,
								        colors )
WORD handle;
WORD FAR *xy;
WORD row_len, num_rows;
WORD FAR *el_used;
WORD FAR *rows_used;
WORD FAR *stat;
WORD FAR *colors;
{
    pblock.ptsin = xy;
    pblock.intout = colors;

    contrl[0] = 27;
    contrl[1] = 2;
    contrl[3] = 0;
    contrl[6] = handle;
    contrl[7] = row_len;
    contrl[8] = num_rows;

    vdi();

    *el_used = contrl[9];
    *rows_used = contrl[10];
    *stat = contrl[11];

    pblock.ptsin = ptsin;
    pblock.intout = intout;
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQL_ATTR.C */

VOID vql_attributes( handle, attributes )
WORD handle;
WORD FAR *attributes;
{
    pblock.intout = attributes;

    contrl[0] = 35;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    pblock.intout = intout;

    attributes[3] = ptsout[0];
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQM_ATTR.C */

VOID vqm_attributes( handle, attributes )
WORD handle;
WORD FAR *attributes;
{
    pblock.intout = attributes;

    contrl[0] = 36;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    pblock.intout = intout;

    attributes[3] = ptsout[1];
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQF_ATTR.C */

VOID vqf_attributes( handle, attributes )
WORD handle;
WORD FAR *attributes;
{
    pblock.intout = attributes;

    contrl[0] = 37;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    pblock.intout = intout;
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQT_ATTR.C */

VOID vqt_attributes( handle, attributes )
WORD handle;
WORD FAR *attributes;
{
    pblock.intout = attributes;
    pblock.ptsout = &attributes[6];

    contrl[0] = 38;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    pblock.intout = intout;
    pblock.ptsout = ptsout;
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQ_EXTND.C */

VOID vq_extnd( handle, owflag, work_out )
WORD handle, owflag;
WORD FAR *work_out;
{
    pblock.intout = work_out;
    pblock.ptsout = &work_out[45];
    intin[0] = owflag;

    contrl[0] = 102;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    pblock.intout = intout;
    pblock.ptsout = ptsout;
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQIN_MOD.C */

VOID vqin_mode( handle, dev_type, mode )
WORD handle, dev_type;
WORD FAR *mode;
{
    intin[0] = dev_type;

    contrl[0] = 115;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    *mode = intout[0];
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQT_EXT.C */

VOID vqt_extent( handle, string, extent )
WORD handle;
WORD FAR *extent;
BYTE FAR *string;
{
    WORD *intstr;

    intstr = intin;
    while ((*intstr++ = (WORD)(UBYTE)*string++) != 0)
        ;
    pblock.ptsout = extent;

    contrl[0] = 116;
    contrl[1] = 0;
    contrl[3] = intstr - intin - 1;
    contrl[6] = handle;

    vdi();

    pblock.ptsout = ptsout;
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQT_WIDT.C */

WORD vqt_width( handle, character, cell_width, left_delta, right_delta )
WORD handle;
WORD FAR *cell_width;
WORD FAR *left_delta;
WORD FAR *right_delta;
BYTE character;
{
    intin[0] = (WORD)(UBYTE)character;

    contrl[0] = 117;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    *cell_width = ptsout[0];
    *left_delta = ptsout[2];
    *right_delta = ptsout[4];

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQT_NAME.C */

WORD vqt_name( handle, element_num, name )
WORD handle, element_num;
BYTE FAR *name;
{
    WORD i;

    intin[0] = element_num;

    contrl[0] = 130;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[6] = handle;

    vdi();

    for (i = 0 ; i < 32 ; i++)
        name[i] = intout[i + 1];

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQT_FOINF.C */

VOID vqt_font_info( handle, minADE, maxADE, distances, maxwidth, effects )
WORD handle;
WORD FAR *minADE;
WORD FAR *maxADE;
WORD FAR *distances;
WORD FAR *maxwidth;
WORD FAR *effects;
{
    contrl[0] = 131;
    contrl[1] = contrl[3] = 0;
    contrl[6] = handle;

    vdi();

    *minADE = intout[0];
    *maxADE = intout[1];
    *maxwidth = ptsout[0];

    distances[0] = ptsout[1];
    distances[1] = ptsout[3];
    distances[2] = ptsout[5];
    distances[3] = ptsout[7];
    distances[4] = ptsout[9];

    effects[0] = ptsout[2];
    effects[1] = ptsout[4];
    effects[2] = ptsout[6];
}

/* LIBMAN: SRC: HDR: NAME: INQUIRE\VQT_JUST.C */

WORD vqt_justified( handle, x, y, string, length, word_space, char_space,
								        offsets)
WORD handle, x, y, length, word_space, char_space;
WORD FAR *offsets;
BYTE FAR *string;
{
    WORD FAR *intstr;

    ptsin[0] = x;
    ptsin[1] = y;
    ptsin[2] = length;
    ptsin[3] = 0;
    intin[0] = word_space;
    intin[1] = char_space;
    intstr = &intin[2];
    while ((*intstr++ = (WORD)(UBYTE)*string++) != 0)
        ;

    contrl[0] = 132;
    contrl[1] = 2;
    contrl[3] = (LONG)intstr - (LONG)intin - 1;
    contrl[6] = handle;
    pblock.ptsout = offsets;

    vdi();

    pblock.ptsout = ptsout;

    return( contrl[2] ); /* contrl[4] ???? */
}

/* LIBMAN: LIB: HDR: NAME: ESCAPE.C */

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VQ_CHCEL.C */

VOID vq_chcells( handle, rows, columns )
WORD handle;
WORD FAR *rows;
WORD FAR *columns;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 1;
    contrl[6] = handle;

    vdi();

    *rows = intout[0];
    *columns = intout[1];
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_EX_CUR.C */

VOID v_exit_cur( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 2;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_EN_CUR.C */

VOID v_enter_cur( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 3;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_CURUP.C */

VOID v_curup( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 4;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_CURDOW.C */

VOID v_curdown( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 5;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_CURRI.C */

VOID v_curright( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 6;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_CURLE.C */

VOID v_curleft( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 7;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_CURHO.C */

VOID v_curhome( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 8;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_EEOS.C */

VOID v_eeos( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 9;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_EEOL.C */

VOID v_eeol( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 10;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VS_CURA.C */

VOID vs_curaddress( handle, row, column )
WORD handle, row, column;
{
    intin[0] = row;
    intin[1] = column;

    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[5] = 11;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_CURTEX.C */

VOID v_curtext( handle, string )
WORD handle;
BYTE FAR *string; 
{
    WORD a;
    WORD *intstr;

    a = 0;
    intstr = intin;
    while ((*intstr++ = (WORD)(UBYTE)*string++) != 0)
      a++;

    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = a;
    contrl[5] = 12;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_RVON.C */

VOID v_rvon( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 13;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_RVOFF.C */

VOID v_rvoff( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 14;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VQ_CURAD.C */

VOID vq_curaddress( handle, row, column )
WORD handle;
WORD FAR *row;
WORD FAR *column;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 15;
    contrl[6] = handle;

    vdi();

    *row = intout[0];
    *column = intout[1];
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VQ_TABST.C */

WORD vq_tabstatus( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 16;
    contrl[6] = handle;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_HARDCO.C */

VOID v_hardcopy( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 17;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_DSPCUR.C */

VOID v_dspcur( handle, x, y )
WORD handle, x, y;
{
    ptsin[0] = x;
    ptsin[1] = y;

    contrl[0] = 5;
    contrl[1] = 1;
    contrl[3] = 0;
    contrl[5] = 18;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_RMCUR.C */

VOID v_rmcur( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 19;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_FO_ADV.C */

VOID v_form_adv( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 20;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_OUT_W.C */

VOID v_output_window( handle, xy )
WORD handle;
WORD FAR *xy;
{
    pblock.ptsin = xy;

    contrl[0] = 5;
    contrl[1] = 2;
    contrl[3] = 0;
    contrl[5] = 21;
    contrl[6] = handle;

    vdi();

    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_CLR_DI.C */

VOID v_clear_disp_list( handle )
WORD handle;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 22;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_BIT_IM.C */

VOID v_bit_image( handle, filename, aspect, x_scale, y_scale, h_align, v_align,
									    xy )
WORD handle, aspect, x_scale, y_scale, h_align, v_align;
WORD FAR *xy;
BYTE FAR *filename;
{
    WORD i;

    for (i = 0; i < 4; i++)
        ptsin[i] = xy[i];
    intin[0] = aspect;
    intin[1] = x_scale;
    intin[2] = y_scale;
    intin[3] = h_align;
    intin[4] = v_align;
    i = 5;
    while ((intin[i++] = (WORD)(UBYTE)*filename++) != 0)
        ;

    contrl[0] = 5;
    contrl[1] = 2;
    contrl[3] = --i;
    contrl[5] = 23;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VQ_SCAN.C */

VOID vq_scan( handle, g_height, g_slice, a_height, a_slice, factor )
WORD handle;
WORD FAR *g_height;
WORD FAR *g_slice;
WORD FAR *a_height;
WORD FAR *a_slice;
WORD FAR *factor;
{
    contrl[0] = 5;
    contrl[1] = contrl[3] = 0;
    contrl[5] = 24;
    contrl[6] = handle;

    vdi();

    *g_height = intout[0];
    *g_slice = intout[1];
    *a_height = intout[2];
    *a_slice = intout[3];
    *factor = intout[4];
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_AL_TXT.C */

VOID v_alpha_text( handle, string )
WORD handle;
BYTE FAR *string;
{
    WORD i;

    i = 0;
    while ((intin[i++] = (WORD)(UBYTE)*string++) != 0)
        ;

    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = --i;
    contrl[5] = 25;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VS_PALET.C */

WORD vs_palette( handle, palette )
WORD handle, palette;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[5] = 60;
    contrl[6] = handle;
    intin[0] = palette;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_SOUND.C */

VOID v_sound( handle, frequency, duration )
WORD handle;
WORD frequency;
WORD duration;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[5] = 61;
    contrl[6] = handle;

    intin[0] = frequency;
    intin[1] = duration;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VS_MUTE.C */

WORD vs_mute( handle, action )
WORD handle;
WORD action;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[5] = 62;
    contrl[6] = handle;

    intin[0] = action;

    vdi();

    return( intout[0] );
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VT_RESOL.C */

VOID vt_resolution ( handle, xres, yres, xset, yset )
WORD handle, xres, yres;
WORD FAR *xset;
WORD FAR *yset;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[5] = 81;
    contrl[6] = handle;

    intin[0] = xres;
    intin[1] = yres;

    vdi();

    *xset = intout[0];
    *yset = intout[1];
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VT_AXIS.C */

VOID vt_axis ( handle, xres, yres, xset, yset )
WORD    handle, xres, yres;
WORD FAR *xset;
WORD FAR *yset;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[5] = 82;
    contrl[6] = handle;
    intin[0] = xres;
    intin[1] = yres;
    vdi();
    *xset = intout[0];
    *yset = intout[1];
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VT_ORIGI.C */

VOID vt_origin ( handle, xorigin, yorigin )
WORD handle, xorigin, yorigin;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[5] = 83;
    contrl[6] = handle;

    intin[0] = xorigin;
    intin[1] = yorigin;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VQ_TDIM.C */

VOID vq_tdimensions( handle, xdimension, ydimension )
WORD handle;
WORD FAR *xdimension;
WORD FAR *ydimension;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 0;
    contrl[5] = 84;
    contrl[6] = handle;

    vdi();

    *xdimension = intout[0];
    *ydimension = intout[1];
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VT_ALIGN.C */

VOID vt_alignment( handle, dx, dy )
WORD handle, dx, dy;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[5] = 85;
    contrl[6] = handle;

    intin[0] = dx;
    intin[1] = dy;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VSP_FILM.C */

VOID vsp_film( handle, index, lightness )
WORD handle;
WORD index;
WORD lightness;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[5] = 91;
    contrl[6] = handle;
    intin[0] = index;
    intin[1] = lightness;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VQP_FNAM.C */

BOOLEAN vqp_filmname( handle, index, name )
WORD handle;
WORD index;
BYTE FAR *name;
{
    WORD i;

    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[5] = 92;
    contrl[6] = handle;
    intin[0] = index;

    vdi();

    if ( contrl[4] != 0)
    {
        for (i = 0; i < contrl[4]; i++)
            name[i] = intout[i];
        return(TRUE);
    }

    return(FALSE);
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VSC_EXPO.C */

VOID vsc_expose( handle, state )
WORD handle;
WORD state;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 2;
    contrl[5] = 93;
    contrl[6] = handle;
    intin[0] = state;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_MET_EX.C */

VOID v_meta_extents( handle, min_x, min_y, max_x, max_y )
WORD handle, min_x, min_y, max_x, max_y;
{
    ptsin[0] = min_x;
    ptsin[1] = min_y;
    ptsin[2] = max_x;
    ptsin[3] = max_y;

    contrl[0] = 5;
    contrl[1] = 2;
    contrl[3] = 0;
    contrl[5] = 98;
    contrl[6] = handle;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_WR_MET.C */

VOID v_write_meta( handle, num_ints, ints, num_pts, pts )
WORD handle, num_ints;
WORD FAR *ints;
WORD num_pts;
WORD FAR *pts;
{
    pblock.intin = ints;
    pblock.ptsin = pts;

    contrl[0] = 5;
    contrl[1] = num_pts;
    contrl[3] = num_ints;
    contrl[5] = 99;
    contrl[6] = handle;

    vdi();

    pblock.intin = intin;
    pblock.ptsin = ptsin;
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VM_FNAME.C */

VOID vm_filename( handle, filename )
WORD handle;
BYTE FAR *filename;
{
    WORD *intstr;

    intstr = intin;
    while((*intstr++ = (WORD)(UBYTE)*filename++) != 0)
        ;

    contrl[0] = 5;
    contrl[1] = 0;
    contrl[5] = 100;
    contrl[6] = handle;
    contrl[3] = intstr - intin - 1;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VM_PAGSI.C */

VOID vm_pagesize( handle, pgwidth, pgheight )
WORD handle, pgwidth, pgheight;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 3;
    contrl[5] = 99;
    contrl[6] = handle;

    intin[0] = 0;
    intin[1] = pgwidth;
    intin[2] = pgheight;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VM_COORD.C */

VOID vm_coords( handle, llx, lly, urx, ury )
WORD handle, llx, lly, urx, ury;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 5;
    contrl[5] = 99;
    contrl[6] = handle;

    intin[0] = 1;
    intin[1] = llx;
    intin[2] = lly;
    intin[3] = urx;
    intin[4] = ury;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_COPIES.C */

VOID v_copies(handle, count)
WORD handle, count;
{
    contrl[0] = 5;
    contrl[1] = 0;
    contrl[3] = 1;
    contrl[5] = 28;
    contrl[6] = handle;

    intin[0] = count;

    vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_ORIENT.C */

VOID v_orient( handle, orientation )
WORD handle, orientation ;
{
    contrl[ 0 ] = 5 ;
    contrl[ 1 ] = 0 ;
    contrl[ 3 ] = 1 ;
    contrl[ 5 ] = 27 ;
    contrl[ 6 ] = handle ;

    intin[ 0 ] = orientation ;

    vdi() ;
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_TRAY.C */

VOID v_tray( handle, tray )
WORD handle, tray ;
{
    contrl[ 0 ] = 5 ;
    contrl[ 1 ] = 0 ;
    contrl[ 3 ] = 1 ;
    contrl[ 5 ] = 29 ;
    contrl[ 6 ] = handle ;
 
    intin[ 0 ] = tray ;

    vdi() ;
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_XBITIM.C */

WORD v_xbit_image( handle, filename, aspect, x_scale, y_scale, h_align,
			 	   v_align, rotate, background, foreground, xy )
WORD handle, aspect, x_scale, y_scale, h_align, v_align;
WORD rotate, background, foreground;
WORD FAR *xy;
BYTE FAR *filename;
{
    WORD ii;

    for (ii = 0; ii < 4; ii++)
        ptsin[ ii ] = xy[ ii ] ;

    intin[0] = aspect;
    intin[1] = x_scale;
    intin[2] = y_scale;
    intin[3] = h_align;
    intin[4] = v_align;
    intin[5] = rotate ;
    intin[6] = background ;
    intin[7] = foreground ;
    ii = 8 ;
    while ( *filename )
    {
       intin[ ii++ ] = (WORD)( *filename++ ) ;
    }
    intin[ ii ] = 0 ;           /* final null */

    contrl[0] = 5;
    contrl[1] = 2;
    contrl[3] = ii ;
    contrl[5] = 101 ;
    contrl[6] = handle ; 

    vdi();

    return( TRUE ) ;
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\VS_BKCOL.C */

VOID vs_bkcolor(handle, color)
WORD handle, color;
{
   contrl[0] = 5;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[5] = 102;
   contrl[6] = handle;

   intin[0] = color;

   vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_SETRGB.C */

VOID v_setrgbi(handle, primtype, r, g, b, i)
WORD handle, primtype, r, g, b, i;
{
   contrl[0] = 5;
   contrl[1] = 0;
   contrl[3] = 5;
   contrl[5] = 0x4844;
   contrl[6] = handle;

   intin[0] = primtype;
   intin[1] = r;
   intin[2] = g;
   intin[3] = b;
   intin[4] = i;

   vdi();
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_TOPBOT.C */

VOID v_topbot(handle, height, char_width, char_height, cell_width, cell_height)
WORD handle, height;
WORD FAR *char_width;
WORD FAR *char_height;
WORD FAR *cell_width;
WORD FAR *cell_height;
{
   contrl[0] = 5;
   contrl[1] = 1;
   contrl[3] = 0;
   contrl[5] = 0x4845;
   contrl[6] = handle;

   ptsin[0] = 0;
   ptsin[1] = height;

   vdi();

   *char_width = intout[0];
   *char_height = intout[1];
   *cell_width = intout[2];
   *cell_height = intout[3];
}

/* LIBMAN: SRC: HDR: NAME: ESCAPE\V_PS_HAL.C */

VOID v_ps_halftone(handle, index, angle, frequency)
WORD handle, index, angle, frequency;
{
   contrl[0] = 5;
   contrl[1] = 0;
   contrl[3] = 3;
   contrl[5] = 32;
   contrl[6] = handle;

   intin[0] = index;
   intin[1] = angle;
   intin[2] = frequency;

   vdi();
}

/* VDIBIND.C */
